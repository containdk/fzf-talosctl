#!/usr/bin/env bash

set -euo pipefail

# --- Dependency Checks ---
# Ensure necessary command-line tools are installed before proceeding.
for cmd in talosctl kubectl fzf stdbuf; do
    if ! command -v "$cmd" &> /dev/null;
 then
        echo "Error: Required command '$cmd' is not installed." >&2
        exit 1
    fi
done

# --- Node IP Determination ---
NODE_IP=""
if [ -n "${1-}" ]; then
    # Mode 1: IP is provided as a command-line argument (e.g., from K9s).
    NODE_IP="$1"
else
    # Mode 2: Interactive node selection using fzf.
    echo "No node IP provided. Fetching nodes from current kubectl context..." >&2

    # Get the list of nodes, skipping the header line for fzf processing.
    node_list=$(kubectl get nodes -o wide | tail -n +2)
    if [ -z "$node_list" ]; then
        echo "Error: No nodes found in the current kubectl context." >&2
        exit 1
    fi

    # Use fzf to let the user select a node.
    # The header from `kubectl` is provided to fzf for context.
    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_node_line=$(echo "$node_list" | fzf --prompt="Select Node > " \
        --header="$(kubectl get nodes -o wide | head -n 1)" \
        --header-first)
    set -e # Re-enable exit-on-error

    if [ -z "$selected_node_line" ]; then
        echo "No node selected. Exiting."
        exit 0
    fi

    # Extract the INTERNAL-IP (6th column) from the selected line.
    # This might need adjustment if your `kubectl get nodes -o wide` output is different.
    NODE_IP=$(echo "$selected_node_line" | awk '{print $6}')
fi

if [ -z "$NODE_IP" ]; then
    echo "Error: Could not determine node IP." >&2
    exit 1
fi

# --- Generic Log Viewer for Streaming Logs ---
_view_streaming_logs() {
    local prompt="$1"
    shift
    local talos_cmd=("$@")

    # Start the log command as a managed coprocess. `stdbuf -o0` disables
    # output buffering, ensuring logs appear in fzf immediately.
    # When fzf exits (e.g., via ESC), the `talosctl` process in the pipeline
    # does not always terminate correctly, causing the script to hang.
    # Using a coprocess with an explicit `trap` ensures it is always killed.
    coproc TALOS_LOGS { stdbuf -o0 "${talos_cmd[@]}"; }

    # Run fzf, reading its input from the coprocess's output stream.
    set +e # Temporarily disable exit-on-error for the interactive fzf command
    fzf --prompt="$prompt" \
        --no-sort \
        --tac \
        --wrap \
        --exact \
        --header="[Ctrl-J] Jump to newest | [Ctrl-T] Track/NoTrack | ESC to return" \
        --no-track \
        --bind 'ctrl-j:top,ctrl-t:toggle-track' <&"${TALOS_LOGS[0]}"
    set -e # Re-enable exit-on-error

    # Manually kill the background log process after fzf exits. This is more explicit
    # and robust than using a `trap` on RETURN, which was causing navigation issues.
    kill "${TALOS_LOGS_PID}" &>/dev/null
}

# --- Function for Service Logs Sub-menu ---
handle_service_logs() {
  while true;
  do
    # Get system services (ID is 2nd column from 'talosctl services')
    service_list=$(talosctl -n "$NODE_IP" services 2>/dev/null | tail -n +2 | awk '{print $2}')
    if [ -z "$service_list" ]; then
      echo "Could not retrieve system services from node $NODE_IP. Aborting." >&2
      sleep 3
      return 1
    fi

    # Remove "[Back]" option, rely on ESC for returning
    service_options="$service_list"

    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_service=$(printf "%b" "$service_options" | fzf --prompt="Logs (service) > " --header="[Enter] to select | [ESC] to return" --no-sort)
    set -e # Re-enable exit-on-error

    if [ -z "$selected_service" ]; then
      # User pressed ESC, so we break the loop and return to the main menu.
      break
    fi

    # A service was selected, view its logs.
    # After viewing, the loop will continue, re-displaying the service list.
    _view_streaming_logs "Logs ($selected_service) > " talosctl -n "$NODE_IP" logs --follow "$selected_service"
  done
}

# --- Function for Container Logs Sub-menu ---
handle_container_logs() {
  while true;
  do
    container_output=$(talosctl -n "$NODE_IP" containers -k 2>/dev/null)
    # Use grep to get only container lines (indented with tree characters)
    container_list=$(echo "$container_output" | grep -E '└─|├─')

    if [ -z "$container_list" ]; then
      echo "No containers found on node $NODE_IP (sandboxes are excluded)." >&2
      sleep 3
      return 1
    fi

    # Remove "[Back]" option, rely on ESC for returning
    container_options="$container_list"
    fzf_header=$(echo "$container_output" | head -n 1)

    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_line=$(printf "%b" "$container_options" | fzf --prompt="Logs (container) > " --header="$fzf_header | [ESC] to return" --no-sort)
    set -e # Re-enable exit-on-error
    
    if [ -z "$selected_line" ]; then
      # User pressed ESC, so we break the loop and return to the main menu.
      break
    fi

    # A container was selected, view its logs.
    # The container ID is the 4th field in the line.
    container_id=$(echo "$selected_line" | awk '{print $4}')
    # The container name is the 3rd field.
    container_name=$(echo "$selected_line" | awk '{print $3}')
    _view_streaming_logs "Logs ($container_name) > " talosctl -n "$NODE_IP" logs -k --follow "$container_id"
  done
}

# --- Function for Containers Sub-menu ---
handle_containers() {
    while true; do
        local options="Kubernetes Containers\nSystem Containers" # Removed "[Back]", rely on ESC
        local selected_view

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        selected_view=$(printf "%b" "$options" | fzf --prompt="Container View > " --header="[Enter] to select | [ESC] to return to main menu" --no-sort)
        local exit_code=$?
        set -e # Re-enable exit-on-error

        if [ "$exit_code" -ne 0 ]; then # User pressed ESC or Ctrl-C
            return 0
        fi # This now handles the "back" action for this menu

        case "$selected_view" in
            "Kubernetes Containers")
                set +e
                (set +o pipefail; talosctl -n "$NODE_IP" containers -k | fzf --prompt="K8s Containers > " --header-lines=1 --header="[ESC] to return")
                set -e
                ;;
            "System Containers")
                set +e
                (set +o pipefail; talosctl -n "$NODE_IP" containers | fzf --prompt="System Containers > " --header-lines=1 --header="[ESC] to return")
                set -e
                ;;
            "") return 0 ;; # Should not be reached if exit_code handles ESC
        esac
    done
}

# --- Function for Dmesg Sub-menu ---
handle_dmesg() {
    local sort_key="time"
    local sort_order="r" # Newest first by default

    # Get the full dmesg log once. No --follow.
    local dmesg_log
    # Filter for lines containing a timestamp `[` to handle multi-line entries from talosctl.
    dmesg_log=$(talosctl -n "$NODE_IP" dmesg 2>/dev/null | grep '\[')
    if [ -z "$dmesg_log" ]; then
        echo "Could not retrieve dmesg log from node $NODE_IP." >&2
        sleep 2
        return 1
    fi

    while true; do
        local sorted_log
        if [ "$sort_key" = "time" ]; then
            # Prepend the timestamp to sort, then remove it. Extracts content between [ and ].
            sorted_log=$(echo "$dmesg_log" | awk -F'[][]' '{print $2 "\t" $0}' | command sort -k1,1${sort_order} | cut -f2-)
        elif [ "$sort_key" = "severity" ]; then
            # Prepend severity to sort, then remove it. Extracts 3rd colon-separated field and trims it.
            sorted_log=$(echo "$dmesg_log" | awk -F: '{gsub(/^[ \t]+|[ \t]+$/, "", $3); print $3 "\t" $0}' | command sort -k1,1${sort_order} | cut -f2-)
        else
            # Should not happen, but as a fallback, use original log
            sorted_log="$dmesg_log"
        fi

        local header="[ESC] return | [Ctrl-J] newest | [Ctrl-T] sort time | [Ctrl-S] sort severity | Sort: $sort_key $sort_order"
        local output
        local fzf_opts=(
            --prompt="Dmesg > "
            --header="$header"
            --header-first
            --expect="ctrl-t,ctrl-s"
            --bind='ctrl-j:top'
            --no-sort
            --wrap
            --exact
        )

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%s\n" "$sorted_log" | fzf "${fzf_opts[@]}")
        local exit_code=$?
        set -e # Re-enable exit-on-error
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)

        if [ "$exit_code" -ne 0 ]; then
            # User pressed Esc or Ctrl-C, so return to main menu
            return 0
        fi

        case "$key_pressed" in
            'ctrl-t')
                if [ "$sort_key" = "time" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="time"; sort_order="r"; fi
                ;;
            'ctrl-s')
                if [ "$sort_key" = "severity" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="severity"; sort_order=""; fi
                ;;
            *) # Enter was pressed, just exit back to main menu
                return 0
                ;;
        esac
    done
}

# --- Function for Netstat Sub-menu ---
handle_netstat() {
    local sort_key="" # Default to no specific sort
    local sort_order="" # Default to ascending

    # Get the full netstat log once.
    local netstat_output
    netstat_output=$(talosctl -n "$NODE_IP" netstat -alkpvx 2>/dev/null)

    if [ -z "$netstat_output" ]; then
        echo "Could not retrieve netstat output from node $NODE_IP." >&2
        sleep 2
        return 1
    fi

    # Extract header and data lines. Data lines will have inconsistent column counts.
    # The sorting logic will dynamically handle column extraction based on protocol.
    local netstat_header
    netstat_header=$(echo "$netstat_output" | head -n 1)
    local netstat_data
    netstat_data=$(echo "$netstat_output" | tail -n +2)

    while true; do
        # Build an awk script to prepend the correct sort value based on protocol.
        # This handles the inconsistent column counts between TCP and UDP.
        local sort_awk_script=""
        if [ -n "$sort_key" ]; then
            # shellcheck disable=SC2016
            sort_awk_script='{
                proto = $2;
                sort_val = "";

                # Default column indices for TCP/general case
                col_state=7; col_uid=8; col_program=10; col_pod=11;

                if (proto == "udp" || proto == "udp6") {
                    # Adjust column indices for UDP/UDP6 (State is missing, Uid/Inode/Program/Pod shift left)
                    col_uid=7; col_program=9; col_pod=10;
                }

                # Extract the value based on the requested sort_key and adjusted column indices
                if (sort_key == "proto") sort_val = $2;
                else if (sort_key == "local_address") sort_val = $5;
                else if (sort_key == "foreign_address") sort_val = $6;
                else if (sort_key == "state") { if (proto == "udp" || proto == "udp6") sort_val = ""; else sort_val = $col_state; }
                else if (sort_key == "uid") sort_val = $col_uid;
                else if (sort_key == "program") sort_val = $col_program;
                else if (sort_key == "pod") sort_val = $col_pod;

                print sort_val "\t" $0;
            }'
        fi

        local sorted_data
        if [ -n "$sort_key" ]; then
            # The awk script prepends the correct value for sorting. Pass shell variables to awk.
            # We then sort on that prepended value (k1,1) and then remove it with cut.
            sorted_data=$(echo "$netstat_data" | awk -v sort_key="$sort_key" -v sort_order="$sort_order" \
                "$sort_awk_script" | command sort -k1,1${sort_order} | cut -f2-)
        else
            sorted_data="$netstat_data" # No sort applied
        fi

        local marked_header="$netstat_header"
        if [ -n "$sort_key" ]; then # Only mark header if a sort key is active
            local sort_indicator=" ▲" # ascending
            [ "$sort_order" = "r" ] && sort_indicator=" ▼" # descending

            case "$sort_key" in # Use parameter expansion for simple string replacement
                "proto")           marked_header="${netstat_header//Proto/Proto$sort_indicator}" ;;
                "local_address")   marked_header="${netstat_header//Local Address/Local Address$sort_indicator}" ;;
                "foreign_address") marked_header="${netstat_header//Foreign Address/Foreign Address$sort_indicator}" ;;
                "state")           marked_header="${netstat_header//State/State$sort_indicator}" ;;
                "uid")             marked_header="${netstat_header//Uid/Uid$sort_indicator}" ;;
                "program")         marked_header="${netstat_header//PID\/Program name/PID\/Program name$sort_indicator}" ;;
                "pod")             marked_header="${netstat_header//Pod/Pod$sort_indicator}" ;;
            esac
        fi

        local header="[Ctrl-O] Proto | [Ctrl-L] Local Addr | [Ctrl-F] Foreign Addr | [Ctrl-S] State | [Ctrl-U] Uid | [Ctrl-G] Program | [Ctrl-P] Pod | Sort: $sort_key $sort_order | ESC to return"
        local full_header
        full_header=$(printf "%s\n%s" "$marked_header" "$header")
        local output

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%s\n" "$sorted_data" | fzf \
            --prompt="Netstat > " \
            --header="$full_header" \
            --header-first \
            --expect="ctrl-o,ctrl-l,ctrl-f,ctrl-s,ctrl-u,ctrl-g,ctrl-p" \
            --no-sort \
            --wrap \
            --exact)
        local exit_code=$?
        set -e # Re-enable exit-on-error
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)
        if [ "$exit_code" -ne 0 ]; then return 0; fi # User pressed Esc or Ctrl-C

        # Update sort key and order (using the dynamic awk script)
        case "$key_pressed" in
            'ctrl-o') if [ "$sort_key" = "proto" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="proto"; sort_order=""; fi ;;
            'ctrl-l') if [ "$sort_key" = "local_address" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="local_address"; sort_order=""; fi ;;
            'ctrl-f') if [ "$sort_key" = "foreign_address" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="foreign_address"; sort_order=""; fi ;;
            'ctrl-s') if [ "$sort_key" = "state" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="state"; sort_order=""; fi ;;
            'ctrl-u') if [ "$sort_key" = "uid" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="uid"; sort_order=""; fi ;;
            'ctrl-g') if [ "$sort_key" = "program" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="program"; sort_order=""; fi ;;
            'ctrl-p') if [ "$sort_key" = "pod" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="pod"; sort_order=""; fi ;;
            *) return 0 ;;
        esac
    done
}

# --- Helper Functions for File Browser ---
_get_file_list() {
    local path="$1"
    local key="$2"
    local order="$3"
    # Removed --size-in-bytes for compatibility with older talosctl versions.
    local cmd="talosctl -n $NODE_IP list -l -t d,f,l \"$path\" 2>/dev/null | tail -n +2"

    if [ "$key" = "name" ]; then
        # Use LC_ALL=C for consistent, locale-independent sorting.
        # Sort by the 9th field to the end, as the filename starts at column 9.
        # Use `command sort` to bypass any potential user aliases (e.g., alias sort='sort -r').
        cmd="$cmd | LC_ALL=C command sort -k9${order}"
    elif [ "$key" = "size" ]; then
        # For size sorting, we convert human-readable sizes to bytes using awk,
        # sort numerically, and then remove the temporary byte column.
        # This is compatible with BSD/macOS sort and older talosctl versions.
        cmd="$cmd | awk '{
            size = \$5; # SIZE is the 5th column.
            val = substr(size, 1, length(size)-1);
            unit = substr(size, length(size));
            multiplier = 1;
            if (unit ~ /[kK]/) { multiplier = 1024; }
            else if (unit ~ /[mM]/) { multiplier = 1024*1024; }
            else if (unit ~ /[gG]/) { multiplier = 1024*1024*1024; }
            else if (unit ~ /[tT]/) { multiplier = 1024*1024*1024*1024; }
            else { val = size; } # No unit, assume bytes
            bytes = val * multiplier;
            print bytes, \$0;
        }' | command sort -k1,1n${order} | sed 's/^[0-9.e+]* //'"
    fi

    eval "$cmd"
}

_get_item_name() {
    local item="$1"
    # This awk command correctly extracts the filename, even for symlinks (which have `->`).
    # It iterates from the 9th field (the filename) and stops if it encounters `->`.
    echo "$item" | awk '{
        name=""
        for(i=9; i<=NF; i++) {
            if ($i == "->") break
            name = name (i>9 ? " " : "") $i
        }
        print name
    }'
}

# --- Function for File Browser Sub-menu ---
handle_file_browser() {
    local current_path="/"
    local sort_key="name"
    # Default to 'r' (reverse). In some environments, this is necessary to
    # achieve a standard A-Z alphabetical sort.
    local sort_order="r"

    while true;
    do
        local header="[Enter] select | [ESC] back | [Ctrl-N] name | [Ctrl-S] size | Sort: $sort_key $sort_order"
        local file_list
        file_list=$(_get_file_list "$current_path" "$sort_key" "$sort_order")

        if [ -z "$file_list" ]; then
            echo "Could not retrieve directory listing for '$current_path'." >&2
            sleep 2
            if [ "$current_path" = "/" ]; then
                return 1
            else
                current_path=$(dirname "$current_path")
                continue
            fi
        fi

        # Display ".." at the top and "[Exit]" at the very bottom of the list.
        local options="..\n$file_list" # Removed "[Exit]", rely on ESC from root for main menu
        local output
        
        export -f _get_item_name
        export NODE_IP

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%b" "$options" | fzf \
            --prompt="Browse ($current_path) > " \
            --header="$header" \
            --header-first \
            --expect="ctrl-n,ctrl-s"
        )
        set -e # Re-enable exit-on-error

        local exit_code=$?
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)
        local selected_item
        selected_item=$(echo "$output" | tail -n +2)

        if [ "$exit_code" -ne 0 ]; then
            # User pressed Esc or Ctrl-C
            if [ "$current_path" = "/" ]; then
                return 0
            fi
            current_path=$(dirname "$current_path")
            continue
        fi

        case "$key_pressed" in
            'ctrl-n')
                if [ "$sort_key" = "name" ]; then
                    [ -z "$sort_order" ] && sort_order="r" || sort_order=""
                else
                    sort_key="name"; sort_order="r"
                fi
                ;;
            'ctrl-s')
                if [ "$sort_key" = "size" ]; then
                    [ -z "$sort_order" ] && sort_order="r" || sort_order=""
                else
                    sort_key="size"; sort_order="r"
                fi
                ;;
            *) # This means Enter was pressed
            case "$selected_item" in
                ".." | "")
                    if [ "$current_path" = "/" ]; then
                        return 0
                    else
                        current_path=$(dirname "$current_path") # Go up one directory
                    fi
                    ;;
                *) 
                    local item_type
                    item_type=$(echo "$selected_item" | awk '{print $2}')
                    local item_name
                    item_name=$(_get_item_name "$selected_item")

                    if [[ -n "$selected_item" && "$item_type" == d* ]]; then
                        # It's a directory, so we descend into it.
                        if [ "$current_path" = "/" ]; then
                            current_path="/$item_name"
                        else
                            current_path="$current_path/$item_name"
                        fi
                    elif [[ -n "$selected_item" && ( "$item_type" == -* || "$item_type" == l* ) ]]; then
                        # It's a file, so we view it.
                        # This is done outside of a command substitution to give `less` proper terminal control.
                        local file_path; [ "$current_path" = "/" ] && file_path="/$item_name" || file_path="$current_path/$item_name"
                        set +e # Temporarily disable exit-on-error for the interactive `less` command.
                        talosctl -n "$NODE_IP" read "$file_path" 2>&1 | less -R
                        set -e # Re-enable exit-on-error immediately after.
                    fi
                    ;;
            esac
            ;;
        esac
    done
}


# --- Main Menu Loop ---
while true;
do
    options="Services - Status\nServices - Logs\nNetstat\nMounts\nFile browser\nDmesg\nDashboard (type 'q' to exit)\nContainers - Status\nContainers - Logs\n[Exit]"
    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_action=$(printf "%b" "$options" | fzf --prompt="Talos ($NODE_IP) > " --header="[Enter] to select, [Ctrl-C] or select '[Exit]' to quit" --height=~60% --no-sort)
    set -e # Re-enable exit-on-error

    case "$selected_action" in
        "Containers - Status")
          handle_containers
          ;;
        "Dashboard (type 'q' to exit)")
          set +e; talosctl -n "$NODE_IP" dashboard; set -e
          ;;
        "Dmesg") handle_dmesg ;;
        "File browser") handle_file_browser ;;
        "Containers - Logs") handle_container_logs ;;
        "Services - Logs") handle_service_logs ;;
        "Mounts")
          set +e
          (set +o pipefail; talosctl -n "$NODE_IP" mounts | fzf --prompt="Filter mounts: " --header-lines=1 --header="Tip: start with ' for exact search | [ESC] to return")
          set -e
          ;;
        "Netstat")
          handle_netstat
          ;;
        "Services - Status")
          # Use fzf's preview to show the status of the highlighted service.
          # The preview command extracts the service ID (2nd column) and runs `talosctl services ... status`.
          set +e
          (set +o pipefail; talosctl -n "$NODE_IP" services | fzf \
            --prompt="Services > " \
            --header-lines=1 \
            --header="[ESC] to return" \
            --preview="talosctl -n \"$NODE_IP\" services \$(echo {} | awk '{print \$2}') status 2>/dev/null" \
            --preview-window="right,70%,wrap")
          set -e
          ;;
        "[Exit]" | "") exit 0 ;; 
    esac
done
