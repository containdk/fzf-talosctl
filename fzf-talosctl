#!/usr/bin/env bash

set -euo pipefail

# --- Dependency Checks ---
# Ensure necessary command-line tools are installed before proceeding.
for cmd in talosctl kubectl fzf stdbuf; do
    if ! command -v "$cmd" &> /dev/null;
 then
        echo "Error: Required command '$cmd' is not installed." >&2
        exit 1
    fi
done

# --- Talosconfig Determination ---
# Inform the user which talosconfig file is being used. This follows the same
# logic as talosctl: it prefers the TALOSCONFIG environment variable, and
# falls back to the default path if the variable is not set.
TALOSCONFIG_FILE="${TALOSCONFIG:-$HOME/.talos/config}"
echo "Using talosconfig: $TALOSCONFIG_FILE" >&2

# --- Node IP Determination ---
NODE_IP=""
if [ -n "${1-}" ]; then
    # Mode 1: IP is provided as a command-line argument (e.g., from K9s).
    NODE_IP="$1"

    # Perform a quick check to ensure the node is accessible with the current talosconfig.
    if ! talosctl -n "$NODE_IP" version >/dev/null 2>&1; then
        echo "Error: Unable to connect to node $NODE_IP with current talosconfig." >&2
        echo "Please check your talosconfig and network connectivity." >&2
        exit 1
    fi
else
    # Mode 2: Interactive node selection using fzf. First, get the kubeconfig
    # from the current talosconfig to ensure we query the correct cluster.
    echo "Extracting kubeconfig from current talosconfig..." >&2
    
    TEMP_KUBECONFIG=$(mktemp)
    # Ensure the temporary kubeconfig is cleaned up on script exit.
    trap 'rm -f "$TEMP_KUBECONFIG"' EXIT

    if ! talosctl kubeconfig "$TEMP_KUBECONFIG" >/dev/null 2>&1; then
        echo "Error: Failed to get kubeconfig from talosctl." >&2
        echo "Please ensure your talosconfig is configured correctly." >&2
        exit 1
    fi

    echo "Fetching nodes from the cluster defined in talosconfig..." >&2

    # Get the list of nodes, skipping the header line for fzf processing.
    node_list=$(KUBECONFIG="$TEMP_KUBECONFIG" kubectl get nodes -o wide | tail -n +2)
    if [ -z "$node_list" ]; then
        echo "Error: No nodes found in the cluster defined by your talosconfig." >&2
        exit 1
    fi

    # Use fzf to let the user select a node.
    # The header from `kubectl` is provided to fzf for context.
    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_node_line=$(echo "$node_list" | fzf --prompt="Select Node > " \
        --header="$(KUBECONFIG="$TEMP_KUBECONFIG" kubectl get nodes -o wide | head -n 1)" \
        --header-first)
    set -e # Re-enable exit-on-error

    if [ -z "$selected_node_line" ]; then
        echo "No node selected. Exiting."
        exit 0
    fi

    # Extract the INTERNAL-IP (typically the 6th column) from the selected line.
    # This assumes the standard output format of `kubectl get nodes -o wide`.
    NODE_IP=$(echo "$selected_node_line" | awk '{print $6}')
fi

if [ -z "$NODE_IP" ]; then
    echo "Error: Could not determine node IP." >&2
    exit 1
fi

# --- Direct Action Determination ---
# The second argument can be a direct action to jump into a specific menu.
DIRECT_ACTION="${2-}" # Get the second argument, or empty string if not set.

# --- Generic Log Viewer for Streaming Logs ---
_view_streaming_logs() {
    local prompt="$1"
    shift
    local talos_cmd=("$@")

    # Start the log command as a managed coprocess. `stdbuf -o0` disables
    # output buffering for a real-time feel. The coprocess runs the command
    # in the background and gives us its PID for later management.
    coproc TALOS_LOGS { stdbuf -o0 "${talos_cmd[@]}"; }

    # Run fzf, reading its input from the coprocess's output stream.
    set +e # Temporarily disable exit-on-error for the interactive fzf command
    fzf --prompt="$prompt" \
        --no-sort \
        --tac \
        --wrap \
        --exact \
        --header="[Ctrl-J] Jump to newest | [Ctrl-T] Track/NoTrack | ESC to return" \
        --no-track \
        --bind 'ctrl-j:top,ctrl-t:toggle-track' <&"${TALOS_LOGS[0]}"
    set -e # Re-enable exit-on-error

    # After fzf exits, explicitly kill the background log process to prevent
    # it from hanging and keeping the script alive.
    kill "${TALOS_LOGS_PID}" &>/dev/null
}

# --- Function for Service Logs Sub-menu ---
handle_service_logs() {
  while true;
  do
    # Get system services (ID is 2nd column from 'talosctl services')
    service_list=$(talosctl -n "$NODE_IP" services 2>/dev/null | tail -n +2 | awk '{print $2}')
    if [ -z "$service_list" ]; then
      echo "Could not retrieve system services from node $NODE_IP. Aborting." >&2
      sleep 3
      return 1
    fi

    # The user can press ESC to return to the main menu.
    service_options="$service_list"

    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_service=$(printf "%b" "$service_options" | fzf --prompt="Logs (service) > " --header="[Enter] to select | [ESC] to return" --no-sort)
    set -e # Re-enable exit-on-error

    if [ -z "$selected_service" ]; then
      # User pressed ESC, so we break the loop and return to the main menu.
      break
    fi

    # A service was selected, view its logs.
    # After viewing, the loop will continue, re-displaying the service list.
    _view_streaming_logs "Logs ($selected_service) > " talosctl -n "$NODE_IP" logs --follow "$selected_service"
  done
}

# --- Function for Container Logs Sub-menu ---
handle_container_logs() {
  while true;
  do
    container_output=$(talosctl -n "$NODE_IP" containers -k 2>/dev/null)
    # Use grep to get only container lines (indented with tree characters)
    container_list=$(echo "$container_output" | grep -E '└─|├─')

    if [ -z "$container_list" ]; then
      echo "No containers found on node $NODE_IP (sandboxes are excluded)." >&2
      sleep 3
      return 1
    fi

    # The user can press ESC to return to the main menu.
    container_options="$container_list"
    fzf_header=$(echo "$container_output" | head -n 1)

    set +e # Temporarily disable exit-on-error for the interactive fzf command
    selected_line=$(printf "%b" "$container_options" | fzf --prompt="Logs (container) > " --header="$fzf_header | [ESC] to return" --no-sort)
    set -e # Re-enable exit-on-error
    
    if [ -z "$selected_line" ]; then
      # User pressed ESC, so we break the loop and return to the main menu.
      break
    fi

    # A container was selected, view its logs.
    # The container ID is the 4th field in the line.
    container_id=$(echo "$selected_line" | awk '{print $4}')
    # The container name is the 3rd field.
    container_name=$(echo "$selected_line" | awk '{print $3}')
    _view_streaming_logs "Logs ($container_name) > " talosctl -n "$NODE_IP" logs -k --follow "$container_id"
  done
}

# --- Function for Containers Sub-menu ---
handle_containers() {
    while true; do
        local options="Kubernetes Containers\nSystem Containers"
        local selected_view

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        selected_view=$(printf "%b" "$options" | fzf --prompt="Container View > " --header="[Enter] to select | [ESC] to return to main menu" --no-sort)
        local exit_code=$?
        set -e # Re-enable exit-on-error

        if [ "$exit_code" -ne 0 ]; then # User pressed ESC or Ctrl-C
            return 0 # Return to the main menu.
        fi

        case "$selected_view" in
            "Kubernetes Containers")
                set +e
                (set +o pipefail; talosctl -n "$NODE_IP" containers -k | fzf --prompt="K8s Containers > " --header-lines=1 --header="[ESC] to return")
                set -e
                ;;
            "System Containers")
                set +e
                (set +o pipefail; talosctl -n "$NODE_IP" containers | fzf --prompt="System Containers > " --header-lines=1 --header="[ESC] to return")
                set -e
                ;;
            "") return 0 ;; # This case is unlikely if fzf exits with a non-zero code on ESC.
        esac
    done
}

# --- Function for Dmesg Sub-menu ---
handle_dmesg() {
    # Provides a live stream of kernel messages using 'talosctl dmesg --follow',
    # leveraging the generic streaming log viewer.
    _view_streaming_logs "Dmesg > " talosctl -n "$NODE_IP" dmesg --follow
}

# --- Function for Dashboard ---
handle_dashboard() {
    set +e; talosctl -n "$NODE_IP" dashboard; set -e
}

# --- Function for Mounts ---
handle_mounts() {
    set +e
    (set +o pipefail; talosctl -n "$NODE_IP" mounts | fzf --prompt="Filter mounts: " --header-lines=1 --header="Tip: start with ' for exact search | [ESC] to return")
    set -e
}

# --- Function for Services Status ---
handle_services_status() {
    # Use fzf's preview to show the status of the highlighted service.
    # The preview command extracts the service ID (2nd column) and runs `talosctl services ... status`.
    set +e
    (set +o pipefail; talosctl -n "$NODE_IP" services | fzf \
    --prompt="Services > " \
    --header-lines=1 \
    --header="[ESC] to return" \
    --preview="talosctl -n \"$NODE_IP\" services \$(echo {} | awk '{print \$2}') status 2>/dev/null" \
    --preview-window="right,70%,wrap")
    set -e
}

# --- Function for Netstat Sub-menu ---
handle_netstat() {
    local sort_key="" # Default to no specific sort
    local sort_order="" # Default to ascending

    # Get the full netstat log once.
    local netstat_output
    netstat_output=$(talosctl -n "$NODE_IP" netstat -alkpvx 2>/dev/null)

    if [ -z "$netstat_output" ]; then
        echo "Could not retrieve netstat output from node $NODE_IP." >&2
        sleep 2
        return 1
    fi

    # Extract header and data lines. Data lines will have inconsistent column counts.
    # The sorting logic will dynamically handle column extraction based on protocol.
    local netstat_header
    netstat_header=$(echo "$netstat_output" | head -n 1)
    local netstat_data
    netstat_data=$(echo "$netstat_output" | tail -n +2)

    while true; do
        # Build an awk script to prepend the correct sort value based on protocol.
        # This handles the inconsistent column counts between TCP and UDP.
        local sort_awk_script=""
        if [ -n "$sort_key" ]; then
            # shellcheck disable=SC2016
            sort_awk_script='{
                proto = $2;
                sort_val = "";

                # Default column indices for TCP/general case
                col_state=7; col_uid=8; col_program=10; col_pod=11;

                if (proto == "udp" || proto == "udp6") {
                    # Adjust column indices for UDP/UDP6 (State is missing, Uid/Inode/Program/Pod shift left)
                    col_uid=7; col_program=9; col_pod=10;
                }

                # Extract the value based on the requested sort_key and adjusted column indices
                if (sort_key == "proto") sort_val = $2;
                else if (sort_key == "local_address") sort_val = $5;
                else if (sort_key == "foreign_address") sort_val = $6;
                else if (sort_key == "state") { if (proto == "udp" || proto == "udp6") sort_val = ""; else sort_val = $col_state; }
                else if (sort_key == "uid") sort_val = $col_uid;
                else if (sort_key == "program") sort_val = $col_program;
                else if (sort_key == "pod") sort_val = $col_pod;

                print sort_val "\t" $0;
            }'
        fi

        local sorted_data
        if [ -n "$sort_key" ]; then
            # The awk script prepends the correct value for sorting. Pass shell variables to awk.
            # We then sort on that prepended value (k1,1) and then remove it with cut.
            sorted_data=$(echo "$netstat_data" | awk -v sort_key="$sort_key" -v sort_order="$sort_order" \
                "$sort_awk_script" | command sort -k1,1${sort_order} | cut -f2-)
        else
            sorted_data="$netstat_data" # No sort applied
        fi

        local marked_header="$netstat_header"
        if [ -n "$sort_key" ]; then # Only mark header if a sort key is active
            local sort_indicator=" ▲" # ascending
            [ "$sort_order" = "r" ] && sort_indicator=" ▼" # descending

            case "$sort_key" in # Use parameter expansion for simple string replacement
                "proto")           marked_header="${netstat_header//Proto/Proto$sort_indicator}" ;;
                "local_address")   marked_header="${netstat_header//Local Address/Local Address$sort_indicator}" ;;
                "foreign_address") marked_header="${netstat_header//Foreign Address/Foreign Address$sort_indicator}" ;;
                "state")           marked_header="${netstat_header//State/State$sort_indicator}" ;;
                "uid")             marked_header="${netstat_header//Uid/Uid$sort_indicator}" ;;
                "program")         marked_header="${netstat_header//PID\/Program name/PID\/Program name$sort_indicator}" ;;
                "pod")             marked_header="${netstat_header//Pod/Pod$sort_indicator}" ;;
            esac
        fi

        local header="[Ctrl-O] Proto | [Ctrl-L] Local Addr | [Ctrl-F] Foreign Addr | [Ctrl-S] State | [Ctrl-U] Uid | [Ctrl-G] Program | [Ctrl-P] Pod | Sort: $sort_key $sort_order | ESC to return"
        local full_header
        full_header=$(printf "%s\n%s" "$marked_header" "$header")
        local output

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%s\n" "$sorted_data" | fzf \
            --prompt="Netstat > " \
            --header="$full_header" \
            --header-first \
            --expect="ctrl-o,ctrl-l,ctrl-f,ctrl-s,ctrl-u,ctrl-g,ctrl-p" \
            --no-sort \
            --wrap \
            --exact)
        local exit_code=$?
        set -e # Re-enable exit-on-error
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)
        if [ "$exit_code" -ne 0 ]; then return 0; fi # User pressed Esc or Ctrl-C

        # Update sort key and order (using the dynamic awk script)
        case "$key_pressed" in
            'ctrl-o') if [ "$sort_key" = "proto" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="proto"; sort_order=""; fi ;;
            'ctrl-l') if [ "$sort_key" = "local_address" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="local_address"; sort_order=""; fi ;;
            'ctrl-f') if [ "$sort_key" = "foreign_address" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="foreign_address"; sort_order=""; fi ;;
            'ctrl-s') if [ "$sort_key" = "state" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="state"; sort_order=""; fi ;;
            'ctrl-u') if [ "$sort_key" = "uid" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="uid"; sort_order=""; fi ;;
            'ctrl-g') if [ "$sort_key" = "program" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="program"; sort_order=""; fi ;;
            'ctrl-p') if [ "$sort_key" = "pod" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="pod"; sort_order=""; fi ;;
            *) return 0 ;;
        esac
    done
}

# --- Helper Functions for File Browser ---
_get_file_list() {
    local path="$1"
    local key="$2"
    local order="$3"
    # The `list` command is used without `--size-in-bytes` to maintain
    # compatibility with a wider range of talosctl versions.
    local cmd="talosctl -n $NODE_IP list -l -t d,f,l \"$path\" 2>/dev/null | tail -n +2"

    if [ "$key" = "name" ]; then
        # Use LC_ALL=C for consistent, locale-independent sorting.
        # Sort by the 9th field to the end, as the filename starts at column 9.
        # Use `command sort` to bypass any potential user aliases (e.g., alias sort='sort -r').
        cmd="$cmd | LC_ALL=C command sort -k9${order}"
    elif [ "$key" = "size" ]; then
        # For size sorting, we convert human-readable sizes to bytes using awk,
        # sort numerically, and then remove the temporary byte column.
        # This approach is compatible with both GNU and BSD/macOS versions of sort.
        cmd="$cmd | awk '{
            size = \$5; # SIZE is the 5th column.
            val = substr(size, 1, length(size)-1);
            unit = substr(size, length(size));
            multiplier = 1;
            if (unit ~ /[kK]/) { multiplier = 1024; }
            else if (unit ~ /[mM]/) { multiplier = 1024*1024; }
            else if (unit ~ /[gG]/) { multiplier = 1024*1024*1024; }
            else if (unit ~ /[tT]/) { multiplier = 1024*1024*1024*1024; }
            else { val = size; } # No unit, assume bytes
            bytes = val * multiplier;
            print bytes, \$0;
        }' | command sort -k1,1n${order} | sed 's/^[0-9.e+]* //'"
    fi

    eval "$cmd"
}

_get_item_name() {
    local item="$1"
    # This awk command correctly extracts the filename, even for symlinks (which have `->`).
    # It iterates from the 9th field (the filename) and stops if it encounters `->`.
    echo "$item" | awk '{
        name=""
        for(i=9; i<=NF; i++) {
            if ($i == "->") break
            name = name (i>9 ? " " : "") $i
        }
        print name
    }'
}

# --- Function for File Browser Sub-menu ---
handle_file_browser() {
    local current_path="/"
    local sort_key="name"
    # Default to 'r' (reverse). In some environments, this provides a more
    # natural A-Z alphabetical sort.
    local sort_order="r"

    while true;
    do
        local header="[Enter] select | [ESC] back | [Ctrl-N] name | [Ctrl-S] size | Sort: $sort_key $sort_order"
        local file_list
        file_list=$(_get_file_list "$current_path" "$sort_key" "$sort_order")

        if [ -z "$file_list" ]; then
            echo "Could not retrieve directory listing for '$current_path'." >&2
            sleep 2
            if [ "$current_path" = "/" ]; then
                return 1
            else
                current_path=$(dirname "$current_path")
                continue
            fi
        fi

        # Prepend ".." to the list to allow navigating up the directory tree.
        local options="..\n$file_list"
        local output
        
        export -f _get_item_name
        export NODE_IP

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%b" "$options" | fzf \
            --prompt="Browse ($current_path) > " \
            --header="$header" \
            --header-first \
            --expect="ctrl-n,ctrl-s"
        )
        set -e # Re-enable exit-on-error

        local exit_code=$?
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)
        local selected_item
        selected_item=$(echo "$output" | tail -n +2)

        if [ "$exit_code" -ne 0 ]; then
            # User pressed Esc or Ctrl-C
            if [ "$current_path" = "/" ]; then
                return 0
            fi
            current_path=$(dirname "$current_path")
            continue
        fi

        case "$key_pressed" in
            'ctrl-n')
                if [ "$sort_key" = "name" ]; then
                    [ -z "$sort_order" ] && sort_order="r" || sort_order=""
                else
                    sort_key="name"; sort_order="r"
                fi
                ;;
            'ctrl-s')
                if [ "$sort_key" = "size" ]; then
                    [ -z "$sort_order" ] && sort_order="r" || sort_order=""
                else
                    sort_key="size"; sort_order="r"
                fi
                ;;
            *) # This means Enter was pressed
            case "$selected_item" in
                ".." | "")
                    if [ "$current_path" = "/" ]; then
                        return 0
                    else
                        current_path=$(dirname "$current_path") # Go up one directory
                    fi
                    ;;
                *) 
                    local item_type
                    item_type=$(echo "$selected_item" | awk '{print $2}')
                    local item_name
                    item_name=$(_get_item_name "$selected_item")

                    if [[ -n "$selected_item" && "$item_type" == d* ]]; then
                        # It's a directory, so we descend into it.
                        if [ "$current_path" = "/" ]; then
                            current_path="/$item_name"
                        else
                            current_path="$current_path/$item_name"
                        fi
                    elif [[ -n "$selected_item" && ( "$item_type" == -* || "$item_type" == l* ) ]]; then
                        # It's a file or symlink, so we view its contents.
                        # This is done outside of a command substitution to give `less` proper terminal control.
                        local file_path; [ "$current_path" = "/" ] && file_path="/$item_name" || file_path="$current_path/$item_name"
                        set +e # Temporarily disable exit-on-error for the interactive `less` command.
                        talosctl -n "$NODE_IP" read "$file_path" 2>&1 | less -R
                        set -e # Re-enable exit-on-error immediately after.
                    fi
                    ;;
            esac
            ;;
        esac
    done
}

# --- Function for Processes Sub-menu ---
handle_processes() {
    local sort_key="" # Default to no specific sort
    local sort_order="" # Default to ascending

    local processes_output
    processes_output=$(talosctl -n "$NODE_IP" processes 2>/dev/null)

    if [ -z "$processes_output" ]; then
        echo "Could not retrieve process list from node $NODE_IP." >&2
        sleep 2
        return 1
    fi

    local processes_header
    processes_header=$(echo "$processes_output" | head -n 1)
    local processes_data
    processes_data=$(echo "$processes_output" | tail -n +2)

    while true; do
        local sort_awk_script=""
        if [ -n "$sort_key" ]; then
            # Awk function to convert human-readable memory sizes (e.g., "1.5 GB") to bytes for sorting.
            # SC2016: Expressions don't expand in single quotes. This is intentional for awk.
            # shellcheck disable=SC2016
            sort_awk_script='
            function convert_to_bytes(val) {
                # This function converts a string like "1.5 GB" or "287 MB" to bytes.
                # It is designed to be POSIX-compliant and robust.

                # Default to 0 if input is invalid
                num = 0;
                multiplier = 1;

                # Use match() to find the start of the unit (the first letter).
                # RSTART is a built-in variable set by match().
                if (match(val, /[a-zA-Z]/)) {
                    unit_start_pos = RSTART;
                    # The numeric part is everything before the unit.
                    num_str = substr(val, 1, unit_start_pos - 1);
                    # The unit is everything from the first letter to the end.
                    unit_str = substr(val, unit_start_pos);

                    # Convert the numeric string to a number (the `+ 0` is a standard awk trick).
                    num = num_str + 0;

                    # Determine the multiplier based on the first letter of the unit, case-insensitively.
                    if (unit_str ~ /^[kK]/) multiplier = 1024;
                    else if (unit_str ~ /^[mM]/) multiplier = 1024 * 1024;
                    else if (unit_str ~ /^[gG]/) multiplier = 1024 * 1024 * 1024;
                    else if (unit_str ~ /^[tT]/) multiplier = 1024 * 1024 * 1024 * 1024;
                } else {
                    # No unit found, so the whole string is the number.
                    num = val + 0;
                }

                return num * multiplier;
            }
            {
                sort_val = "";
                if (sort_key == "pid") sort_val = $2;
                else if (sort_key == "threads") sort_val = $4;
                else if (sort_key == "cpu_time") sort_val = $5;
                # The memory columns are split by awk due to the space (e.g., "1.5 GB").
                # We must concatenate them back together before converting to bytes.
                else if (sort_key == "virtmem") sort_val = convert_to_bytes($6 " " $7);
                else if (sort_key == "resmem") sort_val = convert_to_bytes($8 " " $9);

                print sort_val "\t" $0;
            }'
        fi

        local sorted_data
        if [ -n "$sort_key" ]; then
            # The awk script prepends the correct value for sorting. Pass shell variables to awk.
            # We then sort on that prepended value (k1,1) and then remove it with cut.
            # Use `sort -g` for general numeric sort (handles floats and large numbers).
            sorted_data=$(echo "$processes_data" | awk -v sort_key="$sort_key" "$sort_awk_script" | command sort -k1,1g${sort_order} | cut -f2-)
        else
            sorted_data="$processes_data" # No sort applied
        fi

        local marked_header="$processes_header"
        if [ -n "$sort_key" ]; then # Only mark header if a sort key is active
            local sort_indicator=" ▲" # ascending
            [ "$sort_order" = "r" ] && sort_indicator=" ▼" # descending

            case "$sort_key" in
                "pid")       marked_header="${processes_header//PID/PID$sort_indicator}" ;;
                "threads")   marked_header="${processes_header//THREADS/THREADS$sort_indicator}" ;;
                "cpu_time")  marked_header="${processes_header//CPU-TIME/CPU-TIME$sort_indicator}" ;;
                "virtmem")   marked_header="${processes_header//VIRTMEM/VIRTMEM$sort_indicator}" ;;
                "resmem")    marked_header="${processes_header//RESMEM/RESMEM$sort_indicator}" ;;
            esac
        fi

        local header="[Ctrl-P] PID | [Ctrl-T] THREADS | [Ctrl-C] CPU-TIME | [Ctrl-V] VIRTMEM | [Ctrl-R] RESMEM | Sort: $sort_key $sort_order | ESC to return"
        local full_header
        full_header=$(printf "%s\n%s" "$marked_header" "$header")
        local output

        set +e # Temporarily disable exit-on-error for the interactive fzf command
        output=$(printf "%s\n" "$sorted_data" | fzf \
            --prompt="Processes > " \
            --header="$full_header" \
            --header-first \
            --expect="ctrl-p,ctrl-t,ctrl-c,ctrl-v,ctrl-r" \
            --no-sort \
            --wrap \
            --exact)
        local exit_code=$?
        set -e # Re-enable exit-on-error
        local key_pressed
        key_pressed=$(echo "$output" | head -n1)
        if [ "$exit_code" -ne 0 ]; then return 0; fi # User pressed Esc or Ctrl-C

        # Update sort key and order
        case "$key_pressed" in
            'ctrl-p') if [ "$sort_key" = "pid" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="pid"; sort_order=""; fi ;;
            'ctrl-t') if [ "$sort_key" = "threads" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="threads"; sort_order=""; fi ;;
            'ctrl-c') if [ "$sort_key" = "cpu_time" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="cpu_time"; sort_order=""; fi ;;
            'ctrl-v') if [ "$sort_key" = "virtmem" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="virtmem"; sort_order=""; fi ;;
            'ctrl-r') if [ "$sort_key" = "resmem" ]; then [ -z "$sort_order" ] && sort_order="r" || sort_order=""; else sort_key="resmem"; sort_order=""; fi ;;
            *) return 0 ;; # Enter was pressed on a line, or an unhandled key was used.
        esac
    done
}


# --- Main Execution Logic ---
if [ -n "$DIRECT_ACTION" ]; then
    # Direct action mode: execute the specified action and exit.
    case "$DIRECT_ACTION" in
        "containers") handle_containers ;;
        "container-logs") handle_container_logs ;;
        "dashboard") handle_dashboard ;;
        "dmesg") handle_dmesg ;;
        "file-browser") handle_file_browser ;;
        "mounts") handle_mounts ;;
        "netstat") handle_netstat ;;
        "processes") handle_processes ;;
        "service-logs") handle_service_logs ;;
        "services-status") handle_services_status ;;
        *)
            echo "Error: Invalid action '$DIRECT_ACTION'." >&2
            echo "Valid actions are: containers, container-logs, dashboard, dmesg, file-browser, mounts, netstat, processes, service-logs, services-status" >&2
            exit 1
            ;;
    esac
else
    # Interactive mode: show the main menu.
    while true;
    do
        options="Services - Status\nServices - Logs\nNetstat\nProcesses\nMounts\nFile browser\nDmesg\nDashboard (type 'q' to exit)\nContainers - Status\nContainers - Logs\n[Exit]"
        set +e # Temporarily disable exit-on-error for the interactive fzf command
        selected_action=$(printf "%b" "$options" | fzf --prompt="Talos ($NODE_IP) > " --header="[Enter] to select, [Ctrl-C] or select '[Exit]' to quit" --height=~60% --no-sort)
        set -e # Re-enable exit-on-error

        case "$selected_action" in
            "Containers - Status") handle_containers ;;
            "Dashboard (type 'q' to exit)") handle_dashboard ;;
            "Dmesg") handle_dmesg ;;
            "File browser") handle_file_browser ;;
            "Containers - Logs") handle_container_logs ;;
            "Services - Logs") handle_service_logs ;;
            "Processes") handle_processes ;;
            "Mounts") handle_mounts ;;
            "Netstat") handle_netstat ;;
            "Services - Status") handle_services_status ;;
            "[Exit]" | "") exit 0 ;; 
        esac
    done
fi
